<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById("pong");
    const ctx = canvas.getContext("2d");
    canvas.width = 2000; canvas.height = 1250; 

    let gameState = 'LOBBY', mode = 'AI', isHost = true, conn = null, speedMult = 1, shake = 0;
    let currentVolley = 0, aiLevel = 'MEDIUM', particles = [], playerName = "PILOT", opponentName = "CPU";
    const WIN_SCORE = 7;
    const keys = {};

    const p1 = { y: 525, score: 0, targetY: 525 };
    const p2 = { y: 525, score: 0, targetY: 525 };
    const ball = { x: 1000, y: 625, dx: 18, dy: 18 };

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 45;
            this.vy = (Math.random() - 0.5) * 45;
            this.alpha = 1; this.color = color;
            this.size = Math.random() * 10 + 3;
        }
        update() { this.x += this.vx; this.y += this.vy; this.alpha -= 0.03; }
        draw() {
            ctx.save(); ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size); ctx.restore();
        }
    }

    const aiSettings = {
        'EASY': { reaction: 0.04, margin: 130 },
        'MEDIUM': { reaction: 0.13, margin: 60 },
        'HARD': { reaction: 0.38, margin: 0 }
    };

    window.saveName = () => {
        const input = document.getElementById('user-name').value.trim();
        if(input) {
            playerName = input;
            document.getElementById('overlay-name').classList.add('hidden');
            document.getElementById('overlay-start').classList.remove('hidden');
        } else {
            document.getElementById('user-name').style.borderColor = 'red';
        }
    };

    window.setAI = (lvl) => {
        aiLevel = lvl;
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
    };

    window.startAI = () => { mode = 'AI'; isHost = true; opponentName = "CPU"; startGame(); };

    function startGame() {
        gameState = 'PLAYING';
        document.getElementById('overlay-start').classList.add('hidden');
        requestAnimationFrame(gameLoop);
    }

    // UPDATED: Saves both names and handles sync
    function updateLB(v) {
        if (v < 1 || !isHost) return; // Only Host manages the "Source of Truth"
        
        let matchName = `${playerName} vs ${opponentName}`;
        let s = JSON.parse(localStorage.getItem('pong_v5') || '[]');
        s.push({ name: matchName, v: v, d: new Date().toLocaleDateString() });
        s.sort((a,b) => b.v - a.v);
        s = s.slice(0, 8);
        localStorage.setItem('pong_v5', JSON.stringify(s));
        
        renderLB();
        
        // Send updated leaderboard to peer
        if (conn) conn.send({ type: 'LB_SYNC', data: s });
    }

    function renderLB() {
        const list = document.getElementById('lb-list');
        let s = JSON.parse(localStorage.getItem('pong_v5') || '[]');
        list.innerHTML = s.length ? s.map(x => `
            <div class="lb-entry">
                <span style="font-size: 10px;">${x.name}</span>
                <span style="color:var(--neon)">${x.v} HITS</span>
            </div>`).join('') : "No data recorded.";
    }
    renderLB();

    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    const inputMove = (cy) => {
        const rect = canvas.getBoundingClientRect();
        const y = (cy - rect.top) * (1250 / rect.height) - 100;
        if(isHost || mode === 'AI') p1.targetY = y; else p2.targetY = y;
    };
    canvas.addEventListener("mousemove", e => inputMove(e.clientY));
    canvas.addEventListener("touchmove", e => { inputMove(e.touches[0].clientY); e.preventDefault(); }, { passive: false });

    const peer = new Peer();
    peer.on('open', id => document.getElementById('my-id').innerText = id);
    
    // Host Listener
    peer.on('connection', c => {
        conn = c; isHost = true; mode = 'MULTIPLAYER';
        setupPeer();
        conn.on('open', () => { 
            conn.send({ type: 'START', hostName: playerName }); 
            // Sync leaderboard immediately on connect
            let s = JSON.parse(localStorage.getItem('pong_v5') || '[]');
            conn.send({ type: 'LB_SYNC', data: s });
            startGame(); 
        });
    });

    // Guest Joiner
    window.connectToPeer = () => {
        const id = document.getElementById('join-id').value;
        if(!id) return;
        conn = peer.connect(id); isHost = false; mode = 'MULTIPLAYER';
        setupPeer();
        conn.on('open', () => { 
            conn.send({ type: 'JOIN', guestName: playerName }); 
            startGame(); 
        });
    };

    function setupPeer() {
        conn.on('data', data => {
            if (data.type === 'START') { opponentName = data.hostName; startGame(); }
            if (data.type === 'JOIN') { opponentName = data.guestName; }
            if (data.type === 'WIN') endMatch(data.winner);
            
            // Guest receiving leaderboard sync
            if (data.type === 'LB_SYNC') {
                localStorage.setItem('pong_v5', JSON.stringify(data.data));
                renderLB();
            }

            if (isHost) {
                p2.targetY = data.p2Y;
            } else {
                p1.y = data.p1Y; p2.y = data.p2Y; ball.x = data.ballX; ball.y = data.ballY;
                p1.score = data.s1; p2.score = data.s2; speedMult = data.speed; currentVolley = data.vol;
                if(data.hit) burst(data.hit.x, data.hit.y, data.hit.c);
            }
        });
    }

    function burst(x, y, c) { for(let i=0; i<18; i++) particles.push(new Particle(x, y, c)); }

    function update() {
        if (gameState !== 'PLAYING') return;

        let activeP = (isHost || mode === 'AI') ? p1 : p2;
        if (keys['KeyW'] || keys['ArrowUp']) activeP.targetY -= 40;
        if (keys['KeyS'] || keys['ArrowDown']) activeP.targetY += 40;
        
        p1.y += (p1.targetY - p1.y) * 0.28;

        if (mode === 'AI') {
            let s = aiSettings[aiLevel];
            p2.y += (ball.y - 100 + (Math.sin(Date.now()/120)*s.margin) - p2.y) * s.reaction;
        } else {
            p2.y += (p2.targetY - p2.y) * 0.28;
        }

        if (isHost || mode === 'AI') {
            speedMult += 0.003; 
            ball.x += ball.dx * speedMult;
            ball.y += ball.dy * speedMult;

            let hit = null;
            if (ball.y <= 0 || ball.y >= canvas.height) { 
                ball.dy *= -1; shake = 15; burst(ball.x, ball.y, 'white'); 
            }

            if (ball.x < 80 && ball.y > p1.y && ball.y < p1.y + 200) { 
                ball.dx = Math.abs(ball.dx); shake = 30; currentVolley++; 
                hit = { x: 60, y: ball.y, c: '#00f2ff' }; burst(hit.x, hit.y, hit.c);
            }
            if (ball.x > 1920 && ball.y > p2.y && ball.y < p2.y + 200) { 
                ball.dx = -Math.abs(ball.dx); shake = 30; currentVolley++; 
                hit = { x: 1940, y: ball.y, c: '#ff007b' }; burst(hit.x, hit.y, hit.c);
            }

            if (ball.x < 0) { p2.score++; updateLB(currentVolley); resetBall(); }
            if (ball.x > canvas.width) { p1.score++; updateLB(currentVolley); resetBall(); }

            if (p1.score >= WIN_SCORE || p2.score >= WIN_SCORE) {
                let winner = p1.score >= WIN_SCORE ? playerName : opponentName;
                endMatch(winner);
            }
            
            if (conn) conn.send({ p1Y: p1.y, p2Y: p2.y, ballX: ball.x, ballY: ball.y, s1: p1.score, s2: p2.score, speed: speedMult, vol: currentVolley, hit });
        } else if (conn) {
            conn.send({ p2Y: p2.targetY });
        }

        particles.forEach((p, i) => { p.update(); if(p.alpha <= 0) particles.splice(i, 1); });
    }

    function resetBall() {
        ball.x = 1000; ball.y = 625;
        ball.dx = (Math.random() > 0.5 ? 20 : -20);
        ball.dy = (Math.random() > 0.5 ? 15 : -15);
        speedMult = 1; currentVolley = 0;
    }

    function endMatch(w) {
        gameState = 'END';
        document.getElementById('overlay-win').classList.remove('hidden');
        document.getElementById('win-message').innerText = w.toUpperCase() + " WINS";
        document.getElementById('rally-stat').innerText = `Best Rally: ${currentVolley} hits`;
        if(conn && isHost) conn.send({ type: 'WIN', winner: w });
    }

    function draw() {
        ctx.save();
        if (shake > 1) { ctx.translate(Math.random()*shake - shake/2, Math.random()*shake - shake/2); shake *= 0.85; }
        ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = "bold 60px -apple-system"; ctx.fillStyle = "rgba(0, 242, 255, 0.4)"; ctx.textAlign = "center";
        ctx.fillText(`RALLY: ${currentVolley}`, 1000, 100);

        ctx.shadowBlur = 40;
        ctx.fillStyle = "white";
        ctx.shadowColor = "#00f2ff"; ctx.fillRect(40, p1.y, 20, 200);
        ctx.shadowColor = "#ff007b"; ctx.fillRect(1940, p2.y, 20, 200);
        ctx.shadowColor = "white"; ctx.beginPath(); ctx.arc(ball.x, ball.y, 20, 0, Math.PI*2); ctx.fill();

        particles.forEach(p => p.draw());
        
        ctx.shadowBlur = 0;
        ctx.font = "100 250px -apple-system";
        ctx.fillStyle = "rgba(255,255,255,0.05)";
        ctx.fillText(p1.score, 600, 450);
        ctx.fillText(p2.score, 1400, 450);
        ctx.restore();
    }

    function gameLoop() { update(); draw(); if(gameState === 'PLAYING') requestAnimationFrame(gameLoop); }
    window.copyId = () => { navigator.clipboard.writeText(document.getElementById('my-id').innerText); alert("ID Copied"); };
});
</script>
